'use client'

import { useState, useRef, useEffect } from 'react'
import { motion } from 'framer-motion'
import { useAdminStore } from '@/stores/admin-store'
import { FormField, Input, Textarea, Select } from '@/components/admin/shared/form-field'
import { ToggleSwitch } from '@/components/admin/shared/toggle-switch'
import { FileUploadZone } from '@/components/admin/shared/file-upload-zone'
import { extractThumbnailFromVideo, blobToFile } from '@/lib/video/extract-thumbnail'
import { X, Check, Wand2 } from 'lucide-react'
import type { ClipRow, CategoryRow, IntroClipRow, ProfileRow } from '@/types/database'

interface ClipFormProps {
  clip: ClipRow | null
  categories: CategoryRow[]
  introClips: IntroClipRow[]
  profiles: ProfileRow[]
  defaultCategoryId?: string
  onClose: () => void
}

export function ClipForm({
  clip,
  categories,
  introClips,
  profiles,
  defaultCategoryId,
  onClose,
}: ClipFormProps) {
  const { addClip, updateClip } = useAdminStore()
  const [title, setTitle] = useState(clip?.title ?? '')
  const [description, setDescription] = useState(clip?.description ?? '')
  const [categoryId, setCategoryId] = useState(
    clip?.category_id ?? defaultCategoryId ?? ''
  )
  const [introClipId, setIntroClipId] = useState(clip?.intro_clip_id ?? '')
  const [durationSeconds, setDurationSeconds] = useState(
    clip?.duration_seconds?.toString() ?? ''
  )
  const [isActive, setIsActive] = useState(clip?.is_active ?? true)
  const [videoPath, setVideoPath] = useState(clip?.video_path ?? '')
  const [thumbnailPath, setThumbnailPath] = useState(clip?.thumbnail_path ?? '')
  const [videoPreview, setVideoPreview] = useState<string | null>(
    clip?.video_path ? `/api/media/files/${clip.video_path}` : null
  )
  const [thumbnailPreview, setThumbnailPreview] = useState<string | null>(
    clip?.thumbnail_path ? `/api/media/files/${clip.thumbnail_path}` : null
  )
  const [selectedProfileIds, setSelectedProfileIds] = useState<Set<string>>(new Set())
  const [loadingProfiles, setLoadingProfiles] = useState(false)
  const [saving, setSaving] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [thumbnailAutoGenerated, setThumbnailAutoGenerated] = useState(false)
  const [generatingThumbnail, setGeneratingThumbnail] = useState(false)
  const [videoUploadProgress, setVideoUploadProgress] = useState<number | null>(null)
  const [thumbnailUploadProgress, setThumbnailUploadProgress] = useState<number | null>(null)

  // Store pending files for new clips
  const pendingVideoFile = useRef<File | null>(null)
  const pendingThumbnailFile = useRef<File | null>(null)

  const isEditing = !!clip

  // Load existing profile associations when editing
  useEffect(() => {
    async function loadProfileAssociations() {
      if (!clip?.id) return
      setLoadingProfiles(true)
      try {
        const res = await fetch(`/api/admin/clips/${clip.id}/profiles`)
        const data = await res.json()
        if (data.success && Array.isArray(data.data)) {
          setSelectedProfileIds(new Set(data.data))
        }
      } catch (err) {
        console.error('Failed to load profile associations:', err)
      } finally {
        setLoadingProfiles(false)
      }
    }

    loadProfileAssociations()
  }, [clip?.id])

  const toggleProfile = (profileId: string) => {
    setSelectedProfileIds((prev) => {
      const next = new Set(prev)
      if (next.has(profileId)) {
        next.delete(profileId)
      } else {
        next.add(profileId)
      }
      return next
    })
  }

  const selectAllProfiles = () => {
    setSelectedProfileIds(new Set(profiles.map((p) => p.id)))
  }

  const clearAllProfiles = () => {
    setSelectedProfileIds(new Set())
  }

  const generateThumbnailFromVideo = async (videoFile: File) => {
    setGeneratingThumbnail(true)
    try {
      const thumbnailBlob = await extractThumbnailFromVideo(videoFile, {
        captureTime: 1,
        width: 640,
        quality: 0.85,
        format: 'image/webp',
      })
      const thumbnailFile = blobToFile(thumbnailBlob, 'thumbnail.webp')

      pendingThumbnailFile.current = thumbnailFile
      setThumbnailPreview(URL.createObjectURL(thumbnailBlob))
      setThumbnailPath('pending')
      setThumbnailAutoGenerated(true)
    } catch (err) {
      console.error('Failed to generate thumbnail:', err)
      // Don't show error - thumbnail is optional
    } finally {
      setGeneratingThumbnail(false)
    }
  }

  // Direct upload to storage using presigned URL (for large files)
  const uploadDirect = async (
    file: File,
    type: 'video' | 'thumbnail',
    clipId: string,
    onProgress?: (progress: number) => void
  ): Promise<string> => {
    // Get presigned upload URL
    const urlRes = await fetch('/api/admin/upload-url', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        type,
        id: clipId,
        filename: file.name,
        size: file.size,
      }),
    })

    const urlData = await urlRes.json()
    if (!urlData.success) {
      throw new Error(urlData.error || 'Failed to get upload URL')
    }

    const { uploadUrl, storagePath, contentType } = urlData.data

    // Upload directly to storage
    return new Promise((resolve, reject) => {
      const xhr = new XMLHttpRequest()

      xhr.upload.addEventListener('progress', (event) => {
        if (event.lengthComputable && onProgress) {
          const progress = (event.loaded / event.total) * 100
          onProgress(progress)
        }
      })

      xhr.addEventListener('load', async () => {
        if (xhr.status >= 200 && xhr.status < 300) {
          // Confirm upload and update database
          try {
            const confirmRes = await fetch('/api/admin/upload-url', {
              method: 'PUT',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                type,
                id: clipId,
                storagePath,
                filename: file.name,
                size: file.size,
              }),
            })
            const confirmData = await confirmRes.json()
            if (confirmData.success) {
              resolve(storagePath)
            } else {
              reject(new Error(confirmData.error || 'Failed to confirm upload'))
            }
          } catch {
            reject(new Error('Failed to confirm upload'))
          }
        } else {
          reject(new Error(`Direct upload failed with status ${xhr.status}`))
        }
      })

      xhr.addEventListener('error', () => {
        reject(new Error('Network error during direct upload'))
      })

      xhr.addEventListener('timeout', () => {
        reject(new Error('Direct upload timed out'))
      })

      xhr.open('PUT', uploadUrl)
      xhr.setRequestHeader('Content-Type', contentType)
      xhr.timeout = 600000 // 10 minutes for large files
      xhr.send(file)
    })
  }

  // Regular upload through server (for smaller files)
  const uploadViaServer = async (
    file: File,
    type: 'video' | 'thumbnail',
    clipId: string,
    onProgress?: (progress: number) => void
  ): Promise<string> => {
    return new Promise((resolve, reject) => {
      const formData = new FormData()
      formData.append('file', file)
      formData.append('type', type)
      formData.append('id', clipId)

      const xhr = new XMLHttpRequest()

      xhr.upload.addEventListener('progress', (event) => {
        if (event.lengthComputable && onProgress) {
          const progress = (event.loaded / event.total) * 100
          onProgress(progress)
        }
      })

      xhr.addEventListener('load', () => {
        const responseText = xhr.responseText
        const isHtmlResponse = responseText.trim().startsWith('<') || responseText.includes('<!DOCTYPE')

        if (xhr.status >= 200 && xhr.status < 300) {
          if (isHtmlResponse) {
            reject(new Error('Server returned an unexpected response. The file may be too large.'))
            return
          }
          try {
            const data = JSON.parse(responseText)
            if (data.success) {
              resolve(data.data.path)
            } else {
              reject(new Error(data.error || `Failed to upload ${type}`))
            }
          } catch {
            reject(new Error('Invalid response from server. Please try again.'))
          }
        } else if (xhr.status === 413) {
          reject(new Error('File too large. Maximum upload size is 500MB. Please compress the video.'))
        } else if (xhr.status === 502 || xhr.status === 503 || xhr.status === 504) {
          reject(new Error('Server timeout or unavailable. The file may be too large to process. Please try a smaller file.'))
        } else if (xhr.status === 0) {
          reject(new Error('Connection lost during upload. Please check your network and try again.'))
        } else {
          if (isHtmlResponse) {
            reject(new Error(`Upload failed (${xhr.status}). The server may be overloaded or the file too large.`))
            return
          }
          try {
            const data = JSON.parse(responseText)
            reject(new Error(data.error || `Upload failed with status ${xhr.status}`))
          } catch {
            reject(new Error(`Upload failed with status ${xhr.status}. Please try again.`))
          }
        }
      })

      xhr.addEventListener('error', () => {
        reject(new Error('Network error during upload'))
      })

      xhr.addEventListener('timeout', () => {
        reject(new Error('Upload timed out'))
      })

      xhr.open('POST', '/api/admin/upload')
      xhr.timeout = 300000 // 5 minutes
      xhr.send(formData)
    })
  }

  // Main upload function - uses direct upload for large files
  const uploadFile = async (
    file: File,
    type: 'video' | 'thumbnail',
    clipId: string,
    onProgress?: (progress: number) => void
  ): Promise<string> => {
    const DIRECT_UPLOAD_THRESHOLD = 50 * 1024 * 1024 // 50MB

    if (file.size > DIRECT_UPLOAD_THRESHOLD) {
      try {
        return await uploadDirect(file, type, clipId, onProgress)
      } catch (error) {
        // If direct upload fails (e.g., local dev), fall back to server upload
        console.warn('Direct upload failed, trying server upload:', error)
        return await uploadViaServer(file, type, clipId, onProgress)
      }
    }

    return await uploadViaServer(file, type, clipId, onProgress)
  }

  const saveProfileAssociations = async (clipId: string) => {
    const res = await fetch(`/api/admin/clips/${clipId}/profiles`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ profile_ids: Array.from(selectedProfileIds) }),
    })

    const data = await res.json()
    if (!data.success) {
      throw new Error(data.error || 'Failed to save profile associations')
    }
  }

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    setError(null)

    if (!title.trim()) {
      setError('Title is required')
      return
    }

    if (!categoryId) {
      setError('Category is required')
      return
    }

    // For new clips, require a video file to be selected
    if (!isEditing && !pendingVideoFile.current) {
      setError('Video is required')
      return
    }

    // Require at least one profile to be selected
    if (selectedProfileIds.size === 0) {
      setError('Select at least one profile to show this clip to')
      return
    }

    setSaving(true)

    try {
      if (isEditing) {
        // For existing clips, just update metadata
        const res = await fetch(`/api/admin/clips/${clip.id}`, {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            title: title.trim(),
            description: description.trim() || null,
            category_id: categoryId,
            intro_clip_id: introClipId || null,
            is_active: isActive,
            duration_seconds: durationSeconds ? parseInt(durationSeconds, 10) : null,
          }),
        })

        const data = await res.json()
        if (!data.success) {
          setError(data.error || 'Failed to save clip')
          return
        }

        // Save profile associations
        await saveProfileAssociations(clip.id)

        updateClip(clip.id, data.data)
        onClose()
      } else {
        // For new clips:
        // 1. Create clip with placeholder video_path
        const createRes = await fetch('/api/admin/clips', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            title: title.trim(),
            description: description.trim() || null,
            category_id: categoryId,
            intro_clip_id: introClipId || null,
            is_active: isActive,
            duration_seconds: durationSeconds ? parseInt(durationSeconds, 10) : null,
            video_path: 'pending', // Placeholder, will be updated after upload
          }),
        })

        const createData = await createRes.json()
        if (!createData.success) {
          setError(createData.error || 'Failed to create clip')
          return
        }

        const newClipId = createData.data.id

        // 2. Upload video file with progress tracking
        setVideoUploadProgress(0)
        const videoStoragePath = await uploadFile(
          pendingVideoFile.current!,
          'video',
          newClipId,
          (progress) => setVideoUploadProgress(progress)
        )
        setVideoUploadProgress(null)

        // 3. Upload thumbnail if available (either manual or auto-generated)
        let thumbnailStoragePath: string | null = null
        if (pendingThumbnailFile.current) {
          setThumbnailUploadProgress(0)
          thumbnailStoragePath = await uploadFile(
            pendingThumbnailFile.current,
            'thumbnail',
            newClipId,
            (progress) => setThumbnailUploadProgress(progress)
          )
          setThumbnailUploadProgress(null)
        }

        // 4. Save profile associations
        await saveProfileAssociations(newClipId)

        // 5. Update clip with real paths (upload API already updates DB, but let's refresh)
        const updatedClip = {
          ...createData.data,
          video_path: videoStoragePath,
          thumbnail_path: thumbnailStoragePath,
        }

        addClip(updatedClip)
        onClose()
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to save clip')
    } finally {
      setSaving(false)
      setVideoUploadProgress(null)
      setThumbnailUploadProgress(null)
    }
  }

  const handleVideoUpload = async (file: File) => {
    if (!clip?.id) {
      // For new clips, store the file and show local preview
      pendingVideoFile.current = file
      setVideoPreview(URL.createObjectURL(file))
      setVideoPath('pending') // Mark as pending

      // Auto-generate thumbnail if none exists
      if (!pendingThumbnailFile.current && !thumbnailPreview) {
        await generateThumbnailFromVideo(file)
      }
      return
    }

    // For existing clips, upload immediately with progress
    try {
      setVideoUploadProgress(0)
      const videoStoragePath = await uploadFile(
        file,
        'video',
        clip.id,
        (progress) => setVideoUploadProgress(progress)
      )
      setVideoPath(videoStoragePath)
      setVideoPreview(`/api/media/files/${videoStoragePath}`)
      updateClip(clip.id, { video_path: videoStoragePath })

      // Auto-generate thumbnail for existing clip if none exists
      if (!clip.thumbnail_path && !thumbnailPreview) {
        await generateThumbnailFromVideo(file)
        // Upload the generated thumbnail
        if (pendingThumbnailFile.current) {
          setThumbnailUploadProgress(0)
          const thumbPath = await uploadFile(
            pendingThumbnailFile.current,
            'thumbnail',
            clip.id,
            (progress) => setThumbnailUploadProgress(progress)
          )
          setThumbnailPath(thumbPath)
          updateClip(clip.id, { thumbnail_path: thumbPath })
          setThumbnailUploadProgress(null)
        }
      }
    } finally {
      setVideoUploadProgress(null)
    }
  }

  const handleThumbnailUpload = async (file: File) => {
    // Manual thumbnail upload clears auto-generated flag
    setThumbnailAutoGenerated(false)

    if (!clip?.id) {
      // For new clips, store the file and show local preview
      pendingThumbnailFile.current = file
      setThumbnailPreview(URL.createObjectURL(file))
      setThumbnailPath('pending') // Mark as pending
      return
    }

    // For existing clips, upload immediately with progress
    try {
      setThumbnailUploadProgress(0)
      const thumbnailStoragePath = await uploadFile(
        file,
        'thumbnail',
        clip.id,
        (progress) => setThumbnailUploadProgress(progress)
      )
      setThumbnailPath(thumbnailStoragePath)
      setThumbnailPreview(`/api/media/files/${thumbnailStoragePath}`)
      updateClip(clip.id, { thumbnail_path: thumbnailStoragePath })
    } finally {
      setThumbnailUploadProgress(null)
    }
  }

  const handleRegenerateThumbnail = async () => {
    if (pendingVideoFile.current) {
      await generateThumbnailFromVideo(pendingVideoFile.current)
    }
  }

  const activeCategories = categories.filter((c) => c.is_active)

  return (
    <>
      <motion.div
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        exit={{ opacity: 0 }}
        className="fixed inset-0 bg-black/60 z-50"
        onClick={onClose}
      />
      <motion.div
        initial={{ opacity: 0, scale: 0.95 }}
        animate={{ opacity: 1, scale: 1 }}
        exit={{ opacity: 0, scale: 0.95 }}
        className="fixed left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 z-50 w-full max-w-2xl max-h-[90vh] overflow-y-auto"
      >
        <div className="bg-bg-secondary border border-border rounded-xl p-6">
          <div className="flex items-center justify-between mb-6">
            <h2 className="text-xl font-semibold">
              {isEditing ? 'Edit Clip' : 'New Clip'}
            </h2>
            <button
              onClick={onClose}
              className="p-1 hover:bg-bg-card rounded-lg transition-colors"
            >
              <X size={20} />
            </button>
          </div>

          <form onSubmit={handleSubmit} className="space-y-6">
            <div className="grid grid-cols-2 gap-6">
              <FormField label="Video">
                <FileUploadZone
                  accept="video/*,.avi,.mkv,.m4v"
                  onUpload={handleVideoUpload}
                  preview={videoPreview}
                  onClear={() => {
                    setVideoPath('')
                    setVideoPreview(null)
                    pendingVideoFile.current = null
                  }}
                  label="Drop video file here"
                  maxSizeMB={2048}
                  uploadProgress={videoUploadProgress}
                />
              </FormField>

              <FormField label="Thumbnail">
                <div className="space-y-2">
                  <FileUploadZone
                    accept="image/*,.heic,.heif"
                    onUpload={handleThumbnailUpload}
                    preview={thumbnailPreview}
                    onClear={() => {
                      setThumbnailPath('')
                      setThumbnailPreview(null)
                      pendingThumbnailFile.current = null
                      setThumbnailAutoGenerated(false)
                    }}
                    label={generatingThumbnail ? 'Generating...' : 'Drop thumbnail image'}
                    maxSizeMB={10}
                    uploadProgress={thumbnailUploadProgress}
                  />
                  {thumbnailAutoGenerated && thumbnailPreview && (
                    <div className="flex items-center justify-between">
                      <span className="text-xs text-text-muted flex items-center gap-1">
                        <Wand2 size={12} />
                        Auto-generated from video
                      </span>
                      {pendingVideoFile.current && (
                        <button
                          type="button"
                          onClick={handleRegenerateThumbnail}
                          disabled={generatingThumbnail}
                          className="text-xs text-accent hover:underline disabled:opacity-50"
                        >
                          Regenerate
                        </button>
                      )}
                    </div>
                  )}
                  {!thumbnailPreview && !generatingThumbnail && (
                    <p className="text-xs text-text-muted">
                      Thumbnail will be auto-generated from video if not provided
                    </p>
                  )}
                </div>
              </FormField>
            </div>

            <FormField label="Title">
              <Input
                value={title}
                onChange={(e) => setTitle(e.target.value)}
                placeholder="Enter clip title"
              />
            </FormField>

            <FormField label="Description">
              <Textarea
                value={description}
                onChange={(e) => setDescription(e.target.value)}
                placeholder="Enter description (optional)"
                rows={3}
              />
            </FormField>

            <div className="grid grid-cols-2 gap-6">
              <FormField label="Category">
                <Select
                  value={categoryId}
                  onChange={(e) => setCategoryId(e.target.value)}
                >
                  <option value="">Select category</option>
                  {activeCategories.map((category) => (
                    <option key={category.id} value={category.id}>
                      {category.name}
                    </option>
                  ))}
                </Select>
              </FormField>

              <FormField label="Duration (seconds)">
                <Input
                  type="number"
                  value={durationSeconds}
                  onChange={(e) => setDurationSeconds(e.target.value)}
                  placeholder="e.g., 120"
                  min="0"
                />
              </FormField>
            </div>

            <FormField label="Intro Clip (optional)">
              <Select
                value={introClipId}
                onChange={(e) => setIntroClipId(e.target.value)}
              >
                <option value="">No intro</option>
                {introClips
                  .filter((i) => i.is_active)
                  .map((intro) => (
                    <option key={intro.id} value={intro.id}>
                      {intro.name}
                      {intro.duration_seconds
                        ? ` (${intro.duration_seconds}s)`
                        : ''}
                    </option>
                  ))}
              </Select>
              <p className="text-xs text-text-muted mt-1">
                This intro will play before the main video
              </p>
            </FormField>

            {/* Profile Selection */}
            <FormField label="Visible to Profiles">
              <div className="space-y-3">
                <div className="flex gap-2 text-xs">
                  <button
                    type="button"
                    onClick={selectAllProfiles}
                    className="text-accent hover:underline"
                  >
                    Select All
                  </button>
                  <span className="text-text-muted">|</span>
                  <button
                    type="button"
                    onClick={clearAllProfiles}
                    className="text-accent hover:underline"
                  >
                    Clear All
                  </button>
                </div>
                {loadingProfiles ? (
                  <div className="text-sm text-text-muted">Loading profiles...</div>
                ) : (
                  <div className="grid grid-cols-2 gap-2">
                    {profiles.map((profile) => (
                      <button
                        key={profile.id}
                        type="button"
                        onClick={() => toggleProfile(profile.id)}
                        className={`flex items-center gap-3 p-3 rounded-lg border transition-colors text-left ${
                          selectedProfileIds.has(profile.id)
                            ? 'border-accent bg-accent/10'
                            : 'border-border hover:border-text-muted'
                        }`}
                      >
                        <div
                          className={`w-5 h-5 rounded flex items-center justify-center ${
                            selectedProfileIds.has(profile.id)
                              ? 'bg-accent'
                              : 'border border-text-muted'
                          }`}
                        >
                          {selectedProfileIds.has(profile.id) && (
                            <Check size={14} className="text-white" />
                          )}
                        </div>
                        <span className="text-sm">{profile.name}</span>
                      </button>
                    ))}
                  </div>
                )}
                <p className="text-xs text-text-muted">
                  Only selected profiles will see this clip when browsing
                </p>
              </div>
            </FormField>

            <ToggleSwitch
              checked={isActive}
              onChange={setIsActive}
              label={isActive ? 'Active (visible in browse)' : 'Archived'}
            />

            {error && <p className="text-sm text-red-400">{error}</p>}

            <div className="flex justify-end gap-3">
              <button
                type="button"
                onClick={onClose}
                className="px-4 py-2 text-text-secondary hover:text-text-primary transition-colors"
              >
                Cancel
              </button>
              <button
                type="submit"
                disabled={saving || generatingThumbnail}
                className="px-4 py-2 bg-accent hover:bg-accent-hover text-white rounded-lg transition-colors disabled:opacity-50"
              >
                {saving ? 'Saving...' : isEditing ? 'Update' : 'Create'}
              </button>
            </div>
          </form>
        </div>
      </motion.div>
    </>
  )
}
